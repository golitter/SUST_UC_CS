# gcc编译器

GCC（GNU Compiler Collection）是一套由GNU计划开发的自由软件编译器集合，它支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada和Go等。GCC 是一个功能强大、稳定可靠的编译器，被广泛应用于各种操作系统和平台上。

gcc编译器具有以下特点：

1. 多语言支持：GCC提供了对多种编程语言的支持，包括C、C++、Objective-C、Fortran、Ada、Go等。每个语言都有对应的编译器前端，将源代码翻译为GCC内部的中间表示形式。
2. 平台支持：GCC可以运行在多种操作系统和平台上，包括Linux、Windows、macOS、FreeBSD等。它可以为不同的架构生成目标代码，例如x86、ARM、PowerPC等。
3. 优化能力：GCC具有强大的代码优化功能，能够对生成的目标代码进行各种优化，以提高程序的性能和效率。它支持多种优化级别和优化选项，开发人员可以根据需求选择合适的优化设置。
4. 标准符合性：GCC致力于遵循各个编程语言的标准规范，并不断更新和改进以提高对最新语言标准的支持。它严格遵循C、C++等语言的标准，并提供了一些扩展功能以满足特定需求。
5. 可移植性：GCC的源代码是开放的，可以在不同的平台上编译和安装。这使得开发人员可以根据需要进行修改和定制，以适应特定环境和要求。GCC的可移植性也促进了各种开源项目和工具链的开发。
6. 插件架构：GCC提供了一个插件架构，允许开发人员编写和加载各种插件来扩展和增强编译器的功能。这使得用户可以根据需要添加新的分析、优化或转换功能。

gcc的使用格式

```shell
gcc [options] [filenames]
```

gcc的编译过程：

![image-20231018154037161](https://cdn.789ak.com/img/image-20231018154037161.png)

C语言的编译分为四个阶段：预处理、编译、汇编、链接。

1. 预处理阶段：

预处理器会对源代码进行预处理，将包含在头文件中的内容插入到程序中，根据宏定义展开宏，删除注释等。这一阶段生成的文件称为预处理文件，后缀为“.i”。

1. 编译阶段：

编译器会将预处理阶段得到的文件进行编译，生成汇编代码。编译的主要任务是将高级语言翻译成汇编语言，如变量、函数、语句等。这一阶段生成的文件称为汇编文件，后缀为“.s”。

1. 汇编阶段：

汇编器将汇编代码转换成机器码，并生成目标文件。每条汇编指令都被转换为一个或多个机器码指令，也就是二进制表示的指令序列。这一阶段生成的文件称为目标文件，后缀为“.o”。

1. 链接阶段：

链接器将不同的目标文件整合成一个可执行文件。在这个阶段，链接器还会检查目标文件中引用的函数和变量是否已经定义，如果没有，就会报错。这一阶段生成的文件就是我们可以执行的可执行文件，没有后缀名。

### 预处理

预处理器会对源代码进行预处理，将包含在头文件中的内容插入到程序中，根据宏定义展开宏，删除注释等。这一阶段生成的文件称为预处理文件，后缀为“.i”。

| 选项    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| -E      | 只对文件进行预处理，不进行编译，生成的结果送标准输出         |
| -o file | 将输出写到指定的文件file中                                   |
| -I dir  | 指定头文件的路径dir，先在指定路径中搜索要包含的头文件，若找不到，则在标准路径中搜索 |
| -D name | 定义一个宏name，并可以指定值                                 |

```shell
gcc -E lab.c -o lab.i # 将lab.c文件预处理并输出到lab.i文件内
```



![image-20231018154937176](https://cdn.789ak.com/img/image-20231018154937176.png)

### 编译

编译器会将预处理阶段得到的文件进行编译，生成汇编代码。编译的主要任务是将高级语言翻译成汇编语言，如变量、函数、语句等。这一阶段生成的文件称为汇编文件，后缀为“.s”。

编译成汇编代码：

- 源程序 -> 汇编代码
- 预处理文件 -> 汇编代码

| 选项 | 说明                                       |
| ---- | ------------------------------------------ |
| -S   | 只进行编译，不进行汇编，生成汇编代码文件.s |

```shell
gcc -S lab.c # 生成lab.s文件
gcc -S lab.i -o lab2.s # 生成lab2.s文件
```

![image-20231018155437110](https://cdn.789ak.com/img/image-20231018155437110.png)

### 汇编

编译成目标代码

- 源程序 -> 目标代码
- 汇编代码 -> 目标代码

| 选项 | 说明                                     |
| ---- | ---------------------------------------- |
| -c   | 把源文件编译成目标代码( .o )，不进行链接 |

```shell
gcc -c lab.c # 产生lab.o文件
```



![image-20231018155623986](https://cdn.789ak.com/img/image-20231018155623986.png)

```shell
gcc -o out_file file.c # 将文件file.c编译成可执行文件file1；如果未使用该选项，则可执行文件放在a.out中
```

![image-20231018155953015](https://cdn.789ak.com/img/image-20231018155953015.png)

![image-20231018160008666](https://cdn.789ak.com/img/image-20231018160008666.png)

### 多文件编译

![image-20231018160423756](https://cdn.789ak.com/img/image-20231018160423756.png)

```shell
gcc -o ab a.c b.c
```

![image-20231018160516420](https://cdn.789ak.com/img/image-20231018160516420.png)

```shell
gcc -o ab a.o b.o # 这样更优
```

当代码和文件很多时，由于每个文件编译都需要时间，且可能每次编译时只是极个别文件发生了改变，此时用第二种方法较优。

### gcc的其他选项

| 选项  | 说明                                        |
| ----- | ------------------------------------------- |
| -g    | 在目标代码中加入供调试程序gdb使用的附加信息 |
| -v    | 显示gcc版本                                 |
| -Wall | 显示警告信息                                |

- 优化程序选项

| 选项 | 说明                 |
| ---- | -------------------- |
| -O0  | 缺省情况，不优化     |
| -O1  | 一级优化             |
| -O2  | 进行比O1高一级的优化 |
| -O3  | 产生更高级别的优化   |

- 链接选项

| 选项   | 说明                                                  |
| ------ | ----------------------------------------------------- |
| -Ldir  | 将dir所指出的目录加到“函数库搜索列表”中               |
| -iname | 连接时，加载名字为name的函数库（实际的库名是libname） |

>标准库文件一般存储在`/lib`和`/usr/lib`目录中
>
>所有的库名都以`lib`开头

- 库(Library)
  - 静态库(.a文件)
    - 在程序的链接阶段被复制到了程序中
  - 动态库/共享库(.so文件)
    - 在程序运行时系统动态加载到内存中供程序调用

...



# gdb调试工具

GDB（GNU Debugger）是一款功能强大的开源调试工具，用于调试C、C++、Ada、Objective-C、Fortran等多种编程语言的程序。它可以帮助开发者追踪程序运行时的错误和异常，以及对程序进行调试、分析和优化。

- 设置断点
- 监视、修改变量
- 单步执行
- 查看堆栈

ubuntu上安装gdb

```shell
sudo apt update
sudo apt install gdb
```



**使用gdb调试的前提：在程序编译过程中，使用`-g`选项生成可执行文件。**

```shell
gcc -g -o lab lab.c
```

启动gdb

```shell
gdb lab
```

> gdb调试的是可执行文件，不是源文件

![image-20231018164235063](https://cdn.789ak.com/img/image-20231018164235063.png)

### 文件操作

- file命令：装入调试程序
- quit命令：退出gdb
- shell命令：进入shell环境，执行shell命令

### 显示源程序

`list`命令：列出调试程序的源文件。

| 格式           | 说明                         |
| -------------- | ---------------------------- |
| list           | 没有参数，显示当前行开始10行 |
| list +         | 显示当前行之后的10行         |
| list -         | 显示当前行之前的10行         |
| list n         | 显示n行附近的10行            |
| list start,end | 显示从start到end行的代码     |

- `show listsize`：查看显示的行数
- `set listsize`：设置显示的行数

![image-20231018164300651](https://cdn.789ak.com/img/image-20231018164300651.png)

### 控制程序的执行

`break`命令：设置断点

`info breakpoints`：查看断点

![image-20231018164936792](https://cdn.789ak.com/img/image-20231018164936792.png)

`delete`：删除断点

![image-20231018165015697](https://cdn.789ak.com/img/image-20231018165015697.png)

### 程序的运行

`run`：运行程序，执行到断点/程序结束

`next`：单步执行，不进入函数内部

`step`：单步执行，进入函数内部

`continue`：程序从当前位置开始，执行到断点/程序结束

`kill`：终止正在调试的程序

![image-20231018165109917](https://cdn.789ak.com/img/image-20231018165109917.png)

### 查看运行时数据

`print`：显示变量/表达式的值

![image-20231018165145424](C:\Users\19819\AppData\Roaming\Typora\typora-user-images\image-20231018165145424.png)

`set`：修改变量的值

![image-20231018165216982](https://cdn.789ak.com/img/image-20231018165216982.png)

`display`：预先设置一些要显示的表达式



`info display`：显示当前设置的表达式的清单

`delete display`：取消对设置的表达式的自动显示功能



### 显示函数调用堆栈信息

| 格式                  | 说明                   |
| --------------------- | ---------------------- |
| backtrace(bt) / where | 显示函数调用的层次关系 |
| up [n]                | 向上移动n层栈帧        |
| down [n]              | 向下移动n层栈帧        |

![image-20231018165324360](https://cdn.789ak.com/img/image-20231018165324360.png)